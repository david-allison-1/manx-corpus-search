using CorpusSearch.Dependencies.CsvHelper;
using CorpusSearch.Model;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using CorpusSearch.Service;

namespace CorpusSearch.Services;

public class OpenDataLoader
{
    /// <summary>
    /// We copy files in from the "OpenData" directory, which is cloned into by git.
    /// </summary>
    /// <returns></returns>
    public static List<OpenSourceDocument> LoadDocumentsFromFile(LoadConfig lConfig)
    {
        var paths = GetJsonPaths(lConfig);

        var ret = paths
            .Select(ToDocument)
            .ToList();

        ret.ForEach(x => x.GitHubRepo = "david-allison/manx-search-data");

        return ret;

    }

    public static OpenSourceDocument ToDocument(string path)
    {
        try
        {
            OpenSourceDocument document = JsonConvert.DeserializeObject<OpenSourceDocument>(File.ReadAllText(path));
            document.LocationOnDisk = Path.GetDirectoryName(path);
            return document;
        }
        catch (Exception e)
        {
            throw new InvalidOperationException($"Error reading file '{path}'", e);
        }
    }

    public static List<string> GetJsonPaths(LoadConfig lConfig)
    {
        bool videoOnly = lConfig?.VideoOnly ?? false;
        String path = Path.Combine(
            AppDomain.CurrentDomain.BaseDirectory,
            "OpenData" +(videoOnly ? "/Video" : "")
        );
            
        // We use .json.txt so the file opens in the system text editor without explanation.
        // This isn't ideal, but we're likely working with non-technical users outside their comfort zone,
        // and explaining file associations is not ideal

        var allFiles = Directory.GetFiles(path, "*.json.txt", SearchOption.AllDirectories);
        return lConfig?.MaxOpenData > 0
                ? allFiles.Take(lConfig.MaxOpenData).ToList()
                : allFiles.ToList()
            ;
    }

    /// <remarks>
    /// Loads a list of (path, modificationTime) from newdocs.txt, maps this to the IDocument metadata
    /// and returns appropriate metadata to show to users
    /// </remarks>
    /// <exception cref="IOException">Failed to find/read the file recent documents file</exception>

    public static async Task<List<RecentDocument>> LoadRecentDocuments(WorkService workService)
    {
        // OpenData/newdocs.txt in the folder containing the entry point
        // generated by newdocs
        var latestDocumentsFile = Path.Combine(
            AppDomain.CurrentDomain.BaseDirectory,
            "OpenData",
            "newdocs.txt"
        );
             
        var lines = await File.ReadAllLinesAsync(latestDocumentsFile);

        // split a line into data structures:
        // 2024-02-27 04:50:38 OpenData/miscellaneous religious printed 1600 - 1900/Wilsons Sermons/document.csv
        var dateAndPath = lines.Select(line =>
            (
                Date: DateTime.Parse(line[.."2024-02-27 04:50:38".Length]),
                Path: line["2024-02-27 04:50:38 ".Length..]
            )
        );
            
        var allDocuments = await workService.GetAll();

        var csvToDocumentMap = allDocuments.ToDictionary(x => x.RelativeCsvPath, x => x);

        return dateAndPath.Select(obj => new RecentDocument(csvToDocumentMap.GetValueOrDefault(obj.Path), obj.Date))
            .Where(x => x.Document != null)
            .ToList();
    }
}

public static class ClosedDataLoader
{
    public static List<OpenSourceDocument> LoadDocumentsFromFile()
    {
        var paths = GetJsonPaths();
        return paths
            .Select(OpenDataLoader.ToDocument)
            .ToList();
    }

    public static List<string> GetJsonPaths()
    {
        String path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ClosedData");
        // We use .json.txt so the file opens in the system text editor without explanation.
        // This isn't ideal, but we're likely working with non-technical users outside their comfort zone,
        // and explaining file associations is not ideal

        return Directory.GetFiles(path, "*.json.txt", SearchOption.AllDirectories).ToList();
    }
}



/// <summary>
/// A Document to be uploaded to the search - with additional properties regarding folder structure to allow for validation
/// </summary>
public class OpenSourceDocument : Document
{
    /**
     * This abstracts a document (likely a bilingual text) that a user wants to upload: the main goal of this repository
     * We use JSON to define this structure:
     *   * We don't want to use C#: a compile error will be difficult for a non-technical user to diagnose, and it'll break the Unit Tests
     * We use CSV to define the upload as it's both text-based and editable in Excel
     *
     * We store these files in a folder structure with a minimum of:
     * * Document Text (CSV), License, Manifest (JSON)
     *
     * We allow the folder structure so multiple CSV files can have identical names, to allow a logical structure to the documents
     *  and to allow relative paths when defining the PDF
     * This also makes it easy for us to allow each folder to contain additional notes on the document
     */

    public OpenSourceDocument()
    {
        CsvFileName = "document.csv";
    }


    public string LocationOnDisk { get; set; }

    public string FullCsvPath => Path.Combine(LocationOnDisk, CsvFileName);

    public string LicenseLink => Path.Combine(LocationOnDisk, "license.txt");

    internal override List<DocumentLine> LoadLocalFile()
    {
        return CsvHelperUtils.LoadCsv(FullCsvPath);
    }

    private string RelativeLocationOnDisk 
    { 
        get
        {
            if (LocationOnDisk.StartsWith(AppDomain.CurrentDomain.BaseDirectory))
            {
                return LocationOnDisk.Substring(AppDomain.CurrentDomain.BaseDirectory.Length);
            }
            return LocationOnDisk;
        } 
    }

    public override string GitHubRepo { get; set; }
    public override string RelativeCsvPath => RelativeLocationOnDisk + Path.DirectorySeparatorChar + CsvFileName;

    public override string ToString()
    {
        return RelativeLocationOnDisk + Path.DirectorySeparatorChar + "manifest.json";
    }
}